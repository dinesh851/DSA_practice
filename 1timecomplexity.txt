Time Complexities from Best to Worst:

Big-O Notation	Name / Type	Example Use Cases	Performance
O(1)	Constant Time	Accessing an array element by index	ğŸš€ Fastest
O(log n)	Logarithmic Time	Binary Search	ğŸ”¥ Super Fast
O(n)	Linear Time	Looping once through an array	âš¡ Fast
O(n log n)	Linearithmic Time	Efficient sorting (Merge Sort, Timsort)	âš–ï¸ Good
O(nÂ²)	Quadratic Time	Brute-force comparisons (nested loops)	ğŸ¢ Slow
O(nÂ³)	Cubic Time	Triple nested loops	ğŸŒ Slower
O(2â¿)	Exponential Time	Some recursive algorithms (e.g., brute-force subsets)	ğŸš« Very Slow
O(n!)	Factorial Time	Brute-force permutations (like traveling salesman)	ğŸ§¨ Extremely Slow